#include "log.h"
#include <tuple>
#include <assert.h>
#include <iostream>

namespace JINFENG{

#define ISALPHA(ch) ((ch>='a' && ch<='z') || (ch>='A' && ch<='Z'))


/****************************** LogLevel ***************/

std::string LogLevel::ToString(LogLevel::Level level)
{
#define XX(name) \
	case LogLevel::name: return #name; break
	switch(level){
		XX(DEBUG);
		XX(INFO);
		XX(WARN);
		XX(ERROR);
		XX(FATAL);
		default: return "UNKNOW"; break;
	}
#undef XX
}


LogLevel::Level LogLevel::FromString(std::string name)
{
#define XX(name, str) \
	if(name == #str) return LogLevel::str;

	XX(name, DEBUG);
	XX(name, INFO);
	XX(name, WARN);
	XX(name, ERROR);
	XX(name, FATAL);

	return LogLevel::UNKNOW;	
}
#undef XX

/*************************** LogEvent ********************/

LogEvent::~LogEvent()
{
	m_logger->log(shared_from_this());
}

/*************************** LogFormatter ******************/

class StringFormatItem:public LogFormatter::FormatterItem{
public:
	void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
	{
		os<<getFormat();
	}
};

class MessageFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<event->m_ss.str();
        }
};

class LevelFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<LogLevel::ToString(level);
        }
};

class ElapseFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<event->m_elapse;
        }
};

class NameFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<event->m_logger->m_name;
        }
};

class ThreadIdItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<event->ThreadId;
        }
};

class NewLineItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<"\n";
        }
};

class DateTimeFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                struct tm tm;
		time_t time = event->getTime();
		localtime_r(&time, &tm);
		char buf[64];
		strftime(buf, sizeof(buf), m_format.c_str(), &tm);
		os<<buf;
        }
};

class FileNameFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<event->m_fileName;
        }
};

class LineFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<event->m_line;
        }
};

class TabFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<"\t";
        }
};

class FiberFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel::Level level) override
        {
                os<<event->m_fiber;
        }
};

class ThreadNameFormatItem:public LogFormatter::FormatterItem{
public:
        void log(std::ostream& os, LogEvent::ptr event, LogLevel:Level level) override
        {
                os<<event->m_threadName;
        }
};


void LogFormatter::init()
{	//keyword format flag
	std::vector<std::tuple<std::string, std::string, int>> items;

	std::string plainStr;
	for(int i=0;i<m_pattern.size();i++)
	{
		//std::cout<<"first: "<<m_pattern[i]<<std::endl;
		if(m_pattern[i]!='%')
		{
			plainStr += m_pattern[i];
			continue;
		}
		//detected a '%'
		//check the next char 
		if(m_pattern[i+1] == '%')  //next is '%'
		{
			plainStr += '%';
			++i;
			continue;
		}
		//next is keyword
		//if(!plainStr.empty())
		//	std::cout<<"plainStr: "<<plainStr<<std::endl;
		int n = i+1;
		std::string keyword = "";
		std::string format = "";
		bool startformat = false;
		int indformat = 0;
		while(n<m_pattern.size())
		{
			if(startformat==false && m_pattern[n] == '{')
			{
				keyword = m_pattern.substr(i+1, n-i-1);
				//std::cout<<"keyword: "<<keyword<<std::endl;
				startformat = true;
				++n;
				indformat = n;
				continue;
			}else if(startformat==true && m_pattern[n] == '}')
			{
				format = m_pattern.substr(indformat, n-indformat);
				//std::cout<<"format: "<<format<<std::endl;
				startformat = false;
				i = n;		
				break;
			}
			else if(startformat==false && !ISALPHA(m_pattern[n]))
			{
				if(keyword.empty())
					keyword = m_pattern.substr(i+1, n-i-1);
				//std::cout<<"keyword: "<<keyword<<std::endl;
				i = n-1;
				break;
			}
			++n;
			if(n==m_pattern.size())
			{
				keyword = m_pattern.substr(i+1, n-i-1);
				i = m_pattern.size();
				break;
			}

		}
		if(startformat)
		{
			assert(0);
		}
		if(!plainStr.empty())
		{
			items.push_back(std::make_tuple(plainStr, "", 0));
		}
		plainStr = "";
		items.push_back(std::make_tuple(keyword, format, 1));

		//
	}

	/*
	for(auto item: items)
        {
        	std::cout<<std::get<0>(item)<<" "<<std::get<1>(item)<<" "<<std::get<2>(item)<<std::endl;
        }
	*/
	for(auto item: items)
	{
		if(std::get<2>(item)==0)
		{
			m_items.push_back(StringFormatItem(std::get<0>(item))); //plain string
		}
		else{
#define XX(type, ItemFunction) \
	if(std::get<0>(item) == #type) \
		m_items.push_back(std::shared_ptr<FormatterItem::ptr>(new ItemFunction(std::get<1>(item))))
			XX(m, MessageFormatItem),           //m:消息
       			XX(p, LevelFormatItem),             //p:日志级别
        		XX(r, ElapseFormatItem),            //r:累计毫秒数
        		XX(c, NameFormatItem),              //c:日志名称
        		XX(t, ThreadIdFormatItem),          //t:线程id
        		XX(n, NewLineFormatItem),           //n:换行
        		XX(d, DateTimeFormatItem),          //d:时间
        		XX(f, FilenameFormatItem),          //f:文件名
        		XX(l, LineFormatItem),              //l:行号
        		XX(T, TabFormatItem),               //T:Tab
        		XX(F, FiberIdFormatItem),           //F:协程id
        		XX(N, ThreadNameFormatItem),        //N:线程名称
		}
	}
}



void LogFormatter::log(ostream& os, LogEvent::ptr event)
{
	for(auto item: m_items)
	{
		item->log(os, event, 0);
	}	
}	


/******************** FileAppender *************/
void FileLogAppender::log(ofstream& os, LogEvent::ptr event)
{
	m_formatter->log(m_os, event);
}



/****************** StdAppender ****************/
void StdLogAppender::log(ofstream& os, LogEvent::ptr event)
{
	m_formatter->log(std::cout, event);	
}




/********************* Logger ******************/
void Logger::log(LogEvent::ptr event)
{
	for(auto appender: m_appenders)
	{
		appender->log(event);
	}
}

void Logger::addAppender(LogAppender::ptr appender)
{
	m_appenders.push_back(appender);
}

void Logger::delAppender()
{

}

void Logger::setFormatter(LogFormatter::ptr formatter)
{
	m_formatter = formatter;
}

LogFormatter::ptr getFormatter()
{
	return m_formatter;
}

};

